<!DOCTYPE html>
<html>
<head>
  <title>Polyfills are part of the web - TAG finding</title>
  <meta charset='utf-8'>
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
  <script class='remove'>
    var respecConfig = {
      specStatus: "finding",
      shortName: "polyfills",
      publishDate: "2017-01-01",
      format: "markdown",
      editors: [
        { name: "Andrew Betts", url: "https://trib.tv/" }
      ],
      otherLinks: [{
        key: 'Participate',
        data: [
          { value: 'File a bug', href: 'https://github.com/w3ctag/polyfills/issues'},
          { value: 'Commit history', href: 'https://github.com/w3ctag/polyfills/commits/gh-pages'},
          { value: 'Mailing list', href: 'https://lists.w3.org/Archives/Public/www-tag/'}
        ]
      }],
      wg: "Technical Architecture Group",
      wgURI: "https://www.w3.org/2001/tag/",
      wgPublicList: "www-tag",
      wgPatentURI: "https://www.w3.org/2001/tag/disclosures",
      edDraftURI: "https://w3ctag.github.io/polyfills/"
    };
  </script>
</head>
<body>

  <section id="abstract">

    Polyfills are a valuable part of Web architecture, because they promote the adoption of new features during the implementation process. However, polyfills can also create problems for standardisation efforts and therefore for the future of the Web. This document defines the risks, benefits, and role of polyfills on the Web, and proposes best practices for implementors, spec editors, website developers, polyfill authors, and operators of polyfill distribution platforms.

    For deeper background, see relevant [TAG mailing list thread](https://lists.w3.org/Archives/Public/www-tag/2016Oct/0002.html) and [F2F meeting minutes](https://pad.w3ctag.org/p/2016-10-31-minutes.md).

  </section>

  <section id="sotd">

    This document has been produced by the [<abbr title="World Wide Web Consortium">W3C </abbr> Technical Architecture Group (TAG)](https://www.w3.org/2001/tag/).

    The TAG has not yet approved this finding. Please send comments on this finding to the publicly archived TAG mailing list [www-tag@w3.org](mailto:www-tag@w3.org) ([archive](https://lists.w3.org/Archives/Public/www-tag/)).

  </section>

  <section>
    ## Nomenclature: What is a polyfill?

    A *polyfill* is a piece of JavaScript code that is intended to exactly simulate a native, interoperable feature of the web platform, for the purpose of allowing website developers to use modern web features in older browsers.

    The term *polyfill* was coined by Remy Sharp in the 2009 book Introducing HTML5 ([p276](https://books.google.com/books?id=a8HQCk4pbQkC&pg=PA276)), and differentiated from *shim*:

    > What makes a polyfill different from the techniques we have already, like a shim, is this: if you removed the polyfill script, your code would continue to work, without any changes required in spite of the polyfill being removed.

    Since then, the term *prollyfill* has been used by some to refer to code which implements features that are yet to be sufficiently standardised to be considered part of the web platform.  *Ponyfill* is occasionally used to refer to code which implements standard platform features but in a private scope. Other terms such as *nottifill*, *shiv*, *sham*, *shim*, *library* and *patch* also exist and are used with varying degrees of popularity and shared semantics.

    We find that although the term 'polyfill' is the most well recognised of these, its etymology is non-obvious and is [in part culturally specific to the UK](https://remysharp.com/2010/10/08/what-is-a-polyfill/). For the avoidance of confusion, we use the following terms in this finding and offer them as a useful reference:

    * **polyfill**: Simulates a feature of the web platform, interacts with global scope
    * **speculative polyfill** (aka 'prollyfill', 'nottifill'): Simulates a proposed feature of the web platform, interacts with global scope
    * **library** (aka 'polyfill', 'module'): Any code that does not interact directly with global scope or does so with a name that is very unlikely to become a standard feature of the web platform.
  </section>

  <section>

    ## Feature life cycle and the role of polyfills

    From a practical standpoint, the development of web platform features goes through a number of distinct phases:

    1. Idea discussion
    1. Incubation
    1. First native implementation (as a trial / behind flag)
    1. Specification
    1. Multiple interoperable implementations
    1. Universal support

    The time lag between the first interoperable implementations (5) and fully universal support (6) can be long (occasionally as long as a decade). Polyfills can often effectively bridge this gap (between stages 5 and 6 above) and allow site developers to write solutions that assume universal support.

    ## Risks of premature polyfilling

    Any JavaScript library that defines a property of the global object or extends a prototype of a global constructor, using a generically useful name, risks creating problems for the development of the Web if that library becomes widely available, and used, prior to the standardisation and implementation of the feature it seeks to create or emulate.

    <div class="example">
      <p>Example: Mootools</p>
      <p>The standardisation of Array.prototype.contains in JavaScript ran into problems when it became clear that an old version of Mootools had already augmented the Array prototype with a contains method. Websites that included this library would break in a browser that contained a native implementation of a contains method.  The standard method had to be renamed to includes to avoid breaking the web.</p>
    </div>

    <div class="example">
      <p>Example: createShadowRoot</p>
      <p>During the evolution of Web Components, Google created a polyfill for createShadowRoot. The adoption of this polyfill prevented the Working Group from iterating on the API design, so it was deprecated in favour of attachShadow.</p>
    </div>

    In some cases early implementers, cognisant of the possible risks of squatting on potential future web platform APIs which may change, will intentionally use a less common name, or modify the known future API name with a prefix or suffix. However, this can have the effect of encouraging implementers to support the modified name in the eventual native implementation.  The use of vendor names as prefixes further exacerbates this problem if vendors implement APIs under names that identify a different vendor.

    <div class="example">
      <p>Example: requestAnimationFrame</p>
      <p>Safari shipped requestAnimationFrame before other browsers, and the first implementations were available only as webkitRequestAnimationFrame. Today, Microsoft Edge also recognises webkitRequestAnimationFrame despite not being a webkit browser, in order to maximise their compatibility with sites originally optimised for the iPhone.</p>
    </div>

    Polyfill authors can avoid this problem if their version of the feature can be used under the custom name in all browsers, regardless of the existence of any native implementation of the same or similar feature under a different name.  However, many site developers will canonicalise the name of a library by deferring to a 'fantasy' native implementation under a name that might be standardised in future, or which is standardised but only available in some browsers, e.g.:

    <pre>window.requestAnimationFrame = requestAnimationFrame || webkitRequestAnimationFrame || rafEquivLibrary;</pre>

    Following this pattern sets up an assumption that the native implementation, when available, will be functionally identical to the library, which may not be the case.

    ### Tipping point

    It is useful to recognise a point in the lifecycle of a feature at which the definition of the feature is stable enough that polyfills no longer present significant risks to the evolution of the specification, and indeed are now essential to help the feature achieve a more rapid rollout.

    There is no common agreement on how to identify the tipping point, and it may indeed differ depending on the circumstances and type of feature.  We recommend paying attention to the following indicators:

    * Multiple implementations: are there multiple interoperable implementations in shipping browsers?
    * Consensus: Is there broad consensus on the detail of the feature with no unresolved objections that would change the API interface or observed behaviour?
    * Test suite exists: Is there a comprehensive test suite that passes for native implementations?
    * Intent to implement: Is there a publicly declared intention to implement the feature based on the current specification from a major browser vendor?

    It may be difficult for polyfill authors to determine whether a feature has achieved consensus, and in cases where it's unclear, authors should consult the chairs or editors of the feature specification.  In many cases this can be done by opening an issue in a public issue tracker, if the specification effort is using one, or otherwise by sending email to the appropriate mailing list. A lack of response should be interpreted as an indication that a feature has not passed the tipping point.

    ### Other potential concerns

    As the number of web platform features increases, the amount of polyfill code required to make website developers' application code run in older browsers may become extremely large - in some cases exceeding the size of the application code that depends on it.  This has implications for performance, both in terms of parsing the polyfill code, and the time required to download it.

    Consideration should be given to whether excessively large polyfill bundles place a punitive cost burden on users with the least ability to pay that cost: those with older devices which may be on metered connections paying for data in very small increments.

    Polyfills are generally not written by browser vendors, and may not have the infrastructure or support network of a major project, leading to potential security concerns.  These concerns are amplified if the polyfill acquires wide adoption, which may leave many unconnected sites vulnerable to the same security exploit.

  </section>

  <section>

    ## Recommendations for polyfill, library and framework authors

    Polyfill authors can mitigate the concerns outlined above. Following a set of best practices will help to ensure that the polyfill promotes (as is surely intended) the adoption of the feature, rather than standing in the way of its standardisation.

    ### Encapsulate as a module or UMD

    Use standard mechanisms for encapsulating your polyfill, such as ECMAScript modules, <a href='http://wiki.commonjs.org/wiki/CommonJS'>commonJS</a> or <a href='https://github.com/amdjs/amdjs-api/wiki/AMD'>AMD</a>.  If not defining an ES module, use a <a href='https://github.com/umdjs/umd'>universal module declaration</a> to make your polyfill compatible with multiple module loaders.

    Don't pollute the global scope by creating or extending globals when your module is consumed via a module loader.

    ### Use smart distribution

    Choose a platform on which to publish your polyfill from which developers can easily consume it in a way that keeps up to date with changes to the original source.  For example, use a module registry like <a href='https://npmjs.org/'>npmjs.org</a>, and consider hosting the polyfill on a service from which it can be directly loaded in the browser, such as <a href='https://cdnjs.com/'>cdnjs.com</a> or <a href='https://polyfill.io/'>polyfill.io</a>.

    ### Don't create globals with common names for speculative polyfills

    If a feature has not passed the tipping point, do not squat on the common, expected or likely name (whether it's a property of the global object or of a global constructor/prototype).  Consider prefixing or changing the common name, or appending 'polyfill'.  For example, if an upcoming feature is likely to be called `window.API`, consider attaching your polyfill to `window.AlmostAPI` or `window.APIPolyfill`.

    If the feature is a method of an existing global prototype, do not create that method for features that have not passed the tipping point.  Instead, consider creating a standalone function, e.g. `doTheThingPolyfill(element)` instead of `Element.prototype.doTheThing`.

    Do not by default use incredibly short or generic names, such as $, root or web.

    If the feature **has** passed the tipping point, your polyfill is spec-compliant, and it is not being consumed by a module loader, it's OK to attach to the common name.

    ### Pass web platform tests, if they exist

    Attempt to pass <a href='https://github.com/w3c/web-platform-tests'>Web Platform Tests</a> for your polyfill and advertise the results, as a way to help potential consumers of the polyfill more effectively evaluate the risks associated with using the polyfill.

    ### Detect, warn and defer to native implementations

    For features that have reached the tipping point, where the polyfill registers the same name as the native feature, include code to detect a native implementation, and if one exists, defer to it.  Where a native feature exists but is incomplete or buggy, consider using as much of it as possible and correcting only the deficiencies.

    <div class="example">
      <p>Example: searchParams</p>
      <p>Initial implementations of the <a href='https://developer.mozilla.org/en/docs/Web/API/URL#Browser_compatibility'>URL API</a> were almost universally incomplete in that they did not include searchParams. The full specification was only supported by later releases. In the meantime, polyfills could make use of the native support that was available, and add the part that was missing.</p>
    </div>

    When a full fledged native implementation is available, consider throwing a warning to the console to tell the site developer that they loaded a polyfill unnecessarily.

    For features that are yet to reach the tipping point, speculative polyfills should not detect or defer to native implementations, and should not use the same name as a native implementation.

  </section>

  <section>

    ## Recommendations for website developers

    Website developers can achieve maximum benefits from polyfills and by following these best practices.

    ### Understand stability of both feature and polyfill

    Use the lifecycle guidance above to understand whether the feature has passed the tipping point, and can be considered stable. When selecting a polyfill, look for signs of quality such as:

    * Comprehensive test suite, especially if it includes relevant Web Platform Tests</li>
    * Effects on the performance profile of your site, measured using in-browser profiling tools or other auditing or monitoring tools or services

    ### Do not automatically prefer native implementations for speculative polyfills

    If a feature is yet to reach the tipping point, using polyfills that squat on the common name for the feature is highly inadvisable, because when the feature is finalised, it might work differently to the polyfill you are using, and your website may break.  If a polyfill author has followed good practice by providing a polyfill with a non-conflicting name, don't undo this good practice by aliasing it to the common name.

    Instead, use the speculative polyfill as a library, wait until the feature has passed the tipping point, then update your code to use a transparent polyfill that automatically defers to native implementations where they exist.

    ### Do not serve polyfills that are not required by the user

    Shipping unnecessary bytes to users that don't need them wastes the user's time and data allowance. Polyfill authors following good practice may throw a warning if the polyfill is loaded when not needed.

    Consider using feature detection to dynamically determine which polyfills to use.

    ### Implement or make use of an update mechanism

    Don't bake a polyfill into your codebase in a way that does not allow for easy updates from source, especially if the polyfill includes code that automatically defers to a native implementation.  Updating such polyfills regularly will help to ensure that browsers receiving the polyfilled behaviour exhibit the same functionality as those in which you are using the feature natively.

    ### Consider alternative ways of serving users of the slowest, least capable devices

    Typically the devices and browsers that require the largest amount of polyfill code are also the least capable of parsing it efficiently, and the most likely to be on a metered and expensive internet connection.

    Consider setting a baseline of support below which you provide a less enhanced experience that does not require the latest features (that you would otherwise need to polyfill).  Potential alternative solutions for these browsers include:

    * A version of the site that does not require the newer feature
    * A version of the JavaScript 'transpiled' using a server-side tool to replace more modern features with equivalent older ones for the same end result
    * A notice informing the user that their browser is not capable of using that aspect of your site, or the entire site.  This may be appropriate in some cases where the site is an application whose fundamental purpose relies on a particular feature of the web.

    If you implement a baseline, detection of browsers that fall below the line must be based on robust feature detection, not proxy indicators that may be easier to measure but which will also exclude capable browsers.

  </section>

  <section>

    ## Recommendations for polyfill distributors

    If you run a service or project that promotes and distributes polyfills, you can help the web move forward by adhering to the following best practices.

    ### Don't host or serve bad polyfills

    When considering whether to distribute a polyfill, check whether it meets the best practices outlined under the Recommendations for polyfill authors within this finding.

    ### Update polyfills as specifications change

    Keep the polyfills that you host up to date.  If practical, push updates directly to your customers, otherwise encourage them to move to the latest version.

    ### Collect usage data and feed this back to spec editors

    If practical, collect information about which polyfills are most popular, and where site developers are encountering problems using them, or problems with polyfills conflicting with or behaving differently to a native implementation - and send that information to the appropriate parties.

    ### Don't bundle dependencies without declaring them

    If you offer a service that bundles multiple polyfills together, make sure people using the service are able to easily find out which polyfills are being included, and can exclude any polyfills for features that they have already polyfilled earlier or by another means.  This is especially important if your service automatically includes polyfills for features that are dependencies of features requested by the user.

  </section>

</body>
</html>